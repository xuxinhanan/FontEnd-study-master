> **如果 TCP 通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后面的所有请求**，这就是著名的**「队头阻塞」**的问题。



![img](https://upload-images.jianshu.io/upload_images/12206314-30444e59ab9ea3be.png?imageMogr2/auto-orient/strip|imageView2/2/w/1142/format/webp)

这个问题一直是最难解决的 Web 性能问题之一。

---------

### 队头阻塞对 web 性能的影响——高延迟

比如浏览器需要请求一个 JS 文件（先）和一个 CSS 文件。 JS 文件比 CSS 大得多。这种情况下，在下载整个JS文件之前，CSS 必须等待，尽管它要小得多，其实可以更早地解析/使用[^2]。

-----

### HTTP1.1 的补丁解决方案

为此，HTTP1.1做了补丁解决方案：

+ 浏览器为 HTTP/1.1 上的每个页面加载**打开多个 TCP 连接（通常为6个）**。这样，请求可以分布在这些单独的连接上，并且不再有队头阻塞，除非每页有超过6个资源。

+ 并且，**使用 CDN 的实现域名分片机制**。将一个页面的资源利用多个域名下载，提高tcp并发数量。

----

### 补丁解决方案的主要问题

然而，这样方式也有它的不足，这也是 HTTP1.1 的主要问题：**「HTTP/1.1对带宽[^1]的利用率并不理想」**。换句话说就是，**随着带宽的增加，延迟并没有显著下降。**



比如我们常说的 100M 带宽，实际的下载速度能达到 12.5M/S，而采用 HTTP/1.1 时，也许在加载页面资源时最大只能使用到 2.5M/S，很难将 12.5M 全部用满。



之所以会出现这个问题，主要是由以下两个原因导致的：



**第一个原因，TCP 的慢启动。**



一旦一个 TCP 连接建立之后，就进入了发送数据状态，刚开始 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为慢启动。

你可以把每个 TCP 发送数据的过程看成是一辆车的启动过程，当刚进入公路时，会有从 0 到一个稳定速度的提速过程，TCP 的慢启动就类似于该过程。

慢启动是 TCP 为了减少网络拥塞的一种策略，我们是没有办法改变的。

**而之所以说慢启动会带来性能问题，是因为页面中常用的一些关键资源文件本来就不大，如 HTML 文件、CSS 文件和 JavaScript 文件，通常这些文件在 TCP 连接建立好之后就要发起请求的，但这个过程是慢启动，所以耗费的时间比正常的时间要多很多，这样就推迟了宝贵的首次渲染页面的时长了。**



**第二个原因，同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽。**



你可以想象一下，系统同时建立了多条 TCP 连接，当带宽充足时，每条连接发送或者接收速度会慢慢向上增加；而一旦带宽不足时，这些 TCP 连接又会减慢发送或者接收的速度。比如一个页面有 200 个文件，使用了 3 个 CDN，那么加载该网页的时候就需要建立 6 * 3 个 TCP，也就是 18 个 TCP 连接来下载资源；**在下载过程中，当发现带宽不足的时候，各个 TCP 连接就需要动态减慢接收数据的速度。**

这样就会出现一个问题，因为有的 TCP 连接下载的是一些关键资源，如 CSS 文件、JavaScript 文件等，而有的 TCP 连接下载的是图片、视频等普通的资源文件，**但是多条 TCP 连接之间又不能协商让哪些关键资源优先下载，这样就有可能影响那些关键资源的下载速度了。**





[^1]: **带宽是指每秒最大能发送或者接收的字节数。**
[^上行带宽]: 每秒能发送的最大字节数。
[^下行带宽]: 每秒能接收的最大字节数。

[^2]: 由浏览器解析渲染的原理可知， JS 解析前又需要先请求到 CSS 文件，并且生成布局树也需要CSS。

