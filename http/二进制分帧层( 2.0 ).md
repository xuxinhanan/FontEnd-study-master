HTTP/1.1 的主要问题是队头阻塞。**为此提出了「为每个域名开启6个tcp+cdn域名分片」的补丁解决方案。**

然而这个补丁解决方案又带来了新的问题，对带宽的利用率却并不理想。

为此，HTTP/2.0 的目标非常明确：**回到单个 TCP 连接，解决队头阻塞问题**。

而要想在单个 TCP 连接中解决队头阻塞的问题，真正的解决方案是采用**「多路复用」**。

如果我们可以将每个文件的有效荷载（header）分成更小的“块”（chunks），我们就可以在网络上混合或“交错”（interleave）这些块：为 JS 发送一个块，为 CSS 发送一个块，然后再发送另一个用于 JS，等等，直到文件被下载为止。使用这种方法，较小的CSS文件将更早地下载（并且可用），同时只将较大的JS文件延迟一点。用数字形象化我们会得到：

```text
12121111111111111111111111111111111111111
```

这在 HTTP/1.1 中是不可能的，因为没有办法分辨一个块属于哪个资源，或者它在哪里结束，另一个块从哪里开始。

HTTP/2 非常优雅地解决了这一问题，它在资源块之前添加了**「帧」**。

![img](https://pic1.zhimg.com/80/v2-7df511c33a71380a891107aecc978cf8_720w.jpg)

**HTTP/2 在每个块前面放置一个所谓的「数据帧」（DATA frame）。**这些数据帧主要包含两个关键的元数据。

+ 首先：下面的块属于哪个资源。每个资源的“字节流（byte stream）”都被分配了一个唯一的数字，即**流id（stream id）**。
+ 第二：块的大小是多少。协议还有许多其他帧类型，图5也显示了头部帧。这再次使用    `stream id`来指出这些头（headers）属于哪个响应，**这样甚至可以将头（headers）从它们的实际响应数据中分离出来。**

![img](https://pic3.zhimg.com/80/v2-1664a32635c93f2dc1bd30331fc51796_720w.jpg)



浏览器现在可以完美地处理这种情况。它首先处理`script.js`的头部帧（HEADERS frame），然后是第一个JS块的数据帧（DATA frame）。从数据帧（DATA frame）中包含的块长度来看，浏览器知道它只延伸到 TCP 数据包1的末尾，并且需要从 TCP 数据包2开始寻找一个全新的帧。在那里它确实找到了`style.css`的头（HEADERS）， 下一个数据帧（DATA frame）含有与第一个数据帧（1）不同的流 id（2），因此浏览器知道这属于不同的资源。同样的情况也适用于 TCP 数据包3，其中数据帧（DATA frame）流 id 用于将响应块“解复用”（de-multiplex）到正确的资源“流”（streams）。

因此，通过“framing”单个消息，HTTP/2 比 HTTP/1.1 更加灵活。它允许在单个 TCP 连接上通过交错排列块来多路传输多个资源。它还解决了第一个资源缓慢时的队头阻塞问题：而不必等待查询数据库生成的`index.html`，服务器可以在等待`index.html`时开始发送其他资源。

HTTP/2 的方式一个重要结果是，我们突然需要一种方法让资源块应该如何交错。

如果我们再次用 1 和 2 来表示，我们会发现对于 HTTP/1.1，唯一的选项是11112222（我们称之为顺序的（sequential））。然而， HTTP/2 有更多的自由：

- 12121212
- 22122122121
- 22221111
- 112222

使用哪种方法是由 HTTP/2 中所谓的“优先级”决定。



最后，我们就结合图来分析下 HTTP/2 的引入二进制分帧层后请求和接收过程：

![img](https://static001.geekbang.org/resource/image/86/6a/86cdf01a3af7f4f755d28917e58aae6a.png?wh=1142*1156)



+ 首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。
+ 这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。
+ 服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。
+ 然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。
+ 同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。
+ 浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求。

从上面的流程可以看出，通过引入二进制分帧层，就实现了 HTTP 的多路复用技术。

我们知道，HTTP 是浏览器和服务器通信的语言，在这里虽然 HTTP/2 引入了二进制分帧层，不过 HTTP/2 的语义和 HTTP/1.1 依然是一样的，也就是说它们通信的语言并没有改变，比如开发者依然可以通过 Accept 请求头告诉服务器希望接收到什么类型的文件，...... ，**发生改变的只是传输方式。**