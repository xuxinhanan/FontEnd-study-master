> HTTP/1.1 的主要问题是队头阻塞。为此提出了「为每个域名开启6个tcp+cdn域名分片」的补丁解决方案。然而这个补丁解决方案又带来了新的问题，对带宽的利用率却并不理想。

为此，HTTP/2.0 的目标非常明确：**回到单个 TCP 连接，解决队头阻塞问题**。

而要想在单个 TCP 连接中解决队头阻塞的问题，真正的解决方案是采用**「多路复用」**。

如果我们可以将每个文件的有效荷载（header）分成更小的“块”（chunks），我们就可以在网络上“交错传输”这些块：为 JS 发送一个块，为 CSS 发送一个块，然后再发送另一个用于 JS，等等，直到文件被下载为止。使用这种方法，较小的CSS文件将更早地下载（并且可用），同时只将较大的JS文件延迟一点。用数字形象化我们会得到：

```text
12121111111111111111111111111111111111111
```

HTTP/2 通过在资源块之前添加了**「帧」**，非常优雅地实现了这个方案。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B8%A7.png)



HTTP/2 把响应报文划分成了两类 **帧**，图中的 HEADERS（首部）和 DATA（消息负载） 是帧的类型，也就是说一条 HTTP 响应，划分成了两类帧来传输，并且采用二进制来编码。



![img](https://pic1.zhimg.com/80/v2-7df511c33a71380a891107aecc978cf8_720w.jpg)

-------------

**「DATA 帧」**中主要包含两个关键的元数据：

+  **流id（stream id）**：指出这些资源块属于哪个响应
+ **length**：块的大小是多少



-------

### 多路复用传输方式

![img](https://pic3.zhimg.com/80/v2-1664a32635c93f2dc1bd30331fc51796_720w.jpg)



浏览器现在可以完美地处理这种情况。它首先处理`script.js`的头部帧（HEADERS frame），然后是第一个JS块的数据帧（DATA frame）。从数据帧中包含的块长度来看，浏览器知道它只延伸到 TCP 数据包1的末尾，并且需要从 TCP 数据包2开始寻找一个全新的帧。在那里它确实找到了`style.css`的头， 下一个数据帧含有与第一个数据帧（1）不同的流 id（2），因此浏览器知道这属于不同的资源。同样的情况也适用于 TCP 数据包3，其中数据帧 流 id 用于将响应块重组到正确的资源“流”。

------

因此，HTTP/2 比 HTTP/1.1 更加灵活。它允许在单个 TCP 连接上通过交错排列块来多路传输多个资源。它还解决了第一个资源缓慢时的队头阻塞问题：而不必等待查询数据库生成的`index.html`，服务器可以在等待`index.html`时开始发送其他资源。

------

HTTP/2 的方式一个重要结果是，**可以决定资源的“优先级”**。

如果我们再次用 1 和 2 来表示，我们会发现对于 HTTP/1.1，唯一的选项是11112222（我们称之为顺序的）。然而， HTTP/2 有更多的自由：

- 12121212
- 22122122121
- 22221111
- 112222

-----------



最后，分析下 HTTP/2 的引入二进制分帧层后请求和接收过程：

+ 首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。
+ 这些数据经过二进制分帧层处理之后，会**被转换为一个个带有请求 ID 编号的帧**，通过协议栈将这些帧发送给服务器。
+ 服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。
+ 然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。
+ 同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。
+ 浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求。
