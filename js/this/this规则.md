this 是在运行时进行绑定的，并不是在编写时绑定，它的值在函数调用时决定。

this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。

当一个函数被调用时，会创建一个执行上下文。执行上下文记录了函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。this 就是执行上下文的其中一个属性，会在函数执行的过程中用到。

通常来说，寻找调用位置就是寻找“函数被调用的位置”，因此，**最重要的是要分析调用栈**。我们关心的调用位置就在当前正在执行的函数的前一个调用中。

~~~js
function baz() {
  // 当前调用栈是：baz
  // 因此，当前调用位置是全局作用域
  console.log( "baz" );
  bar(); // <-- bar 的调用位置
}
function bar() {
  // 当前调用栈是 baz -> bar
  // 因此，当前调用位置在 baz 中
  console.log( "bar" );
  foo(); // <-- foo 的调用位置
}
function foo() {
  // 当前调用栈是 baz -> bar -> foo
  // 因此，当前调用位置在 bar 中
  console.log( "foo" );
}
baz(); // <-- baz 的调用位置
~~~

2.2　绑定规则

2.2.1　默认绑定

即全局作用域下调用，此时 this 指向的是 window。

注意：如果使用严格模式（strict mode），那么全局对象将无法使用默认绑定，因此 this 会绑定

到 undefined。

2.2.2　隐式绑定

即作为对象的方法调用。 this 指向这个对象。

注意：隐式丢失问题。

一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式。

2.2.3　显式绑定

call、apply、bind方法调用的情况。

bind(..) 会返回一个硬编码的新函数，它会把参数设置为 this 的上下文并调用原始函数。





2.2.4 new绑定

 

在 JavaScript 中，构造函数只是一些使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已。

实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。



**优先级**

优先级: new > call、apply、bind > 对象.方法 > 直接调用。



