### 事件循环

浏览器渲染进程的主线程非常繁忙，要做的事情很多，比如**解析执行js代码 —— <srcipt/> 脚本任务**，**渲染UI**，**用户交互事件**（如鼠标点击）等。

为了有条不紊的处理这些任务于是引入了**事件循环系统和消息队列**。

事件循环系统就是渲染进程的主线程上形成一个执行栈，用来执行所有同步任务，相当于while(true)循环，然后不断取出消息队列中的任务来进行执行。

消息队列的任务有哪些呢？js脚本、定时器、渲染事件（重排重绘合成）、用户交互事件等。

![image-20220510201244808](C:\Users\64554\AppData\Roaming\Typora\typora-user-images\image-20220510201244808.png)



------------------

### 为什么引入微任务，把任务区分为宏任务、微任务呢？

原因是为了**高优先级的任务先处理**。

比如 DOM 节点的修改，如果直接塞到消息队列的尾部，那么实时性很差，因为要等前面的任务执行完毕；而如果做成同步任务，那么当前任务的执行时间会被拉长，从而导致执行效率下降。

针对这种情况，微任务就应运而生了。把消息队列中的任务称为宏任务，并且每个宏任务中包含了一个微任务队列。等宏任务执行完毕后，检查并执行微任务队列的微任务。

微任务系统本质上是 V8 引擎创建全局执行上下文的同时，也会在其内部创建一个微任务队列。产生微任务有两种方式：

一种是使用 MutationObserver 监控某个 DOM 节点，当 DOM 节点变化时就会产生 DOM 变化记录的微任务。

第二种是使用 Promise，当调用 resolve() 或者 reject() 的时候会产生微任务。

