

渲染机制比较复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的 HTML 经过这些子阶段，最后输出 **像素**。我们把这样的一个处理流程叫做渲染流水线，其大致流程如下图所示：

![img](https://static001.geekbang.org/resource/image/92/e8/9259f8732ddad472e5e08a633ad46de8.png?wh=1142*244)

流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。

-------------

## 1. 构建DOM树

在渲染引擎内部，有一个叫 **HTML 解析器**（HTMLParser）的模块，它的职责就是负责将 HTML 字节流转换为 DOM 结构。

![img](https://static001.geekbang.org/resource/image/1b/8c/1bfcd419acf6402c20ffc1a5b1909d8c.png?wh=1142*565)

字节流转换为 DOM 需要三个阶段。

**第一个阶段，通过『分词器』将字节流转换为 Token。**

![img](https://static001.geekbang.org/resource/image/b1/ac/b16d2fbb77e12e376ac0d7edec20ceac.png?wh=1142*151)





**然后将 Token 解析为 DOM 节点，并将 DOM 节点添加到 DOM 树中[^1]。**

HTML 解析器维护了一个 **『Token 栈结构』**，该 Token 栈主要用来计算节点之间的父子关系，在第一个阶段中生成的 Token 会被按照顺序压到这个栈中。具体的处理规则如下所示：

+ 如果压入到栈中的是 **StartTag Token**，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将该节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的节点。
+ 如果分词器解析出来是**文本 Token**，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本 Token 是不需要压入到栈中，它的父节点就是当前栈顶 Token 所对应的 DOM 节点。
+ 如果分词器解析出来的是 **EndTag Token**，比如是 EndTag div，HTML 解析器会查看 Token 栈顶的元素是否是 StarTag div，如果是，就将 StartTag  div 从栈中弹出，表示该 div 元素解析完成。

通过分词器产生的新 Token 就这样不停地压栈和出栈，整个解析过程就这样一直持续下去，直到分词器将所有字节流分词完成。

![img](https://static001.geekbang.org/resource/image/7a/f1/7a6cd022bd51a3f274cd994b1398bef1.png?wh=1142*676)





## 2. 样式计算

CSS 样式来源主要有三种：

+ 通过 link 引用的外部 CSS 文件
+ `<style>`标记内的 CSS
+ 元素的 style 属性内嵌的 CSS



1. 和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时，会执行一个转换操作，**将 CSS 文本转换为浏览器可以理解的结构——styleSheets。**

2. 现在我们已经把现有的 CSS 文本转化为浏览器可以理解的结构了，那么**接下来就要对其进行属性值的标准化操作。**

   ![img](https://static001.geekbang.org/resource/image/12/60/1252c6d3c1a51714606daa6bdad3a560.png?wh=1142*346)

3. 计算出 DOM 树中每个节点的具体样式。

   

## 3. 布局阶段

现在，我们有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。**那么接下来就需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。**



1. 创建布局树

   DOM 树中含有很多不可见的元素，比如 head 标签，还有使用了 display:none 属性的元素。所以在显示之前，我们还要额外地构建一棵只包含可见元素布局树。

   ![img](https://static001.geekbang.org/resource/image/8e/0e/8e48b77dd48bdc509958e73b9935710e.png?wh=1142*984)

2. 现在我们有了一棵完整的布局树。那么接下来，就要计算布局树节点的坐标位置了。





## 4. 分层

因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树。正是这些图层叠加在一起构成了最终的页面图像。

如果没有分层机制，从布局树直接生成目标图片，那么每次页面有很小的变化，都会触发重排或者重绘，严重影响页面的渲染效率。



页面图层如下：

![img](https://static001.geekbang.org/resource/image/e2/c0/e2c917edf5119cddfbec9481372f8fc0.png?wh=1142*1075)





## 5. 生成绘制列表

接下来渲染引擎会将图层的绘制拆分成一个个绘制指令，比如先画背景、再描绘边框......然后将这些指令按顺序组合成一个待绘制列表，用来记录绘制顺序和绘制指令。

![img](https://static001.geekbang.org/resource/image/40/08/40825a55214a7990bba6b9bec6e54108.png?wh=1142*603)





## 6. 栅格化操作

绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。你可以结合下图来看下渲染主线程和合成线程之间的关系：

![img](https://static001.geekbang.org/resource/image/46/41/46d33b6e5fca889ecbfab4516c80a441.png?wh=1142*464)

合成线程首先将图层划分为图块。

![img](https://static001.geekbang.org/resource/image/bc/52/bcc7f6983d5ece8e2dd716f431d0e052.png?wh=1142*995)

因为有些图层很大（比如有的页面使用滚动条滚动好久才能滚到底部），但是通过视口，用户只能看到页面的很小的一部分，这种情况下，要绘制所有图层内容比较浪费性能。

然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。**所谓栅格化，是指将图块转换为位图。**而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的，运行方式如下图所示：

![img](https://static001.geekbang.org/resource/image/d8/20/d8d77356211e12b47bb9f508e2db8520.png?wh=1142*677)

通常，栅格化过程都会使用 GPU 来加速生成，生成的位图被保存在 GPU 内存中。如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的。具体形式你可以参考下图：

![img](https://static001.geekbang.org/resource/image/a8/87/a8d954cd8e4722ee03d14afaa14c3987.png?wh=1142*857)







## 7. 显示

一旦所有图块都被栅格化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。





















[^1]: 这两个步骤是同步进行的。

