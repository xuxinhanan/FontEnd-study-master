

输入的 HTML 经过渲染流水线处理，最后输出 **像素**。其大致流程如下图所示：

![img](https://static001.geekbang.org/resource/image/92/e8/9259f8732ddad472e5e08a633ad46de8.png?wh=1142*244)

流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。

-------------

## 1. 构建DOM树

在渲染引擎内部，有一个叫 **HTML 解析器** 的模块，它的职责就是负责将 HTML 字节流转换为 DOM 结构。

![img](https://static001.geekbang.org/resource/image/1b/8c/1bfcd419acf6402c20ffc1a5b1909d8c.png?wh=1142*565)

字节流转换为 DOM 需要两个阶段。这个过程与 vue 模板编译类似。

**第一个阶段，按照有限状态自动机的规则实现的分词器将字节流切割为一个个 Token。**

![img](https://static001.geekbang.org/resource/image/b1/ac/b16d2fbb77e12e376ac0d7edec20ceac.png?wh=1142*151)





**第二个阶段，根据 Token 列表构建 DOM 树[^1]。**

其实就是对 Token 列表进行扫描的过程。从第一个 Token 开始，顺序地扫描整个 Token 列表，直到列表中的所有 Token 处理完毕。在这个过程中，HTML 解析器维护一个 **Token 栈结构**，用来计算节点之间的父子关系。

每遇到一个开始标签 Token，就将其压入栈中，并构造一个 DOM 节点加入到 DOM 树中。每当遇到一个结束标签 Token，就将当前栈顶的 Token 弹出。

这样，栈顶的 Token 将始终充当父节点的角色，扫描过程中遇到的所有节点都会作为当前栈顶节点的子节点。



![img](https://static001.geekbang.org/resource/image/7a/f1/7a6cd022bd51a3f274cd994b1398bef1.png?wh=1142*676)





## 2. 样式计算

样式计算需要经过三个阶段。

1. **将 CSS 文本转换为浏览器可以理解的结构——styleSheets。[^2]**

2. 有了 styleSheets 之后，**接下来就要对其进行属性值的标准化操作。**

   ![img](https://static001.geekbang.org/resource/image/12/60/1252c6d3c1a51714606daa6bdad3a560.png?wh=1142*346)

3. 计算出 DOM 树中每个节点的具体样式。




CSS 样式来源主要有三种：

+ 通过 link 引用的外部 CSS 文件
+ `<style>`标记内的 CSS
+ 元素的 style 属性内嵌的 CSS



## 3. 布局阶段

现在，我们有 DOM 树和 DOM 树中元素的样式，但我们还不知道 DOM 元素的几何位置信息。**那么接下来就需要计算出 DOM 树中可见元素的几何位置，这个计算过程叫做布局计算。**



1. **创建布局树** [^3]

   ![img](https://static001.geekbang.org/resource/image/8e/0e/8e48b77dd48bdc509958e73b9935710e.png?wh=1142*984)

   

2. 有了布局树后，就要计算布局树节点的坐标位置了。





## 4. 分层

因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的**图层树**。正是这些图层叠加在一起构成了最终的页面图像。[^4]

页面图层如下：

![img](https://static001.geekbang.org/resource/image/e2/c0/e2c917edf5119cddfbec9481372f8fc0.png?wh=1142*1075)





## 5. 生成绘制列表

接下来渲染引擎会将图层的绘制拆分成一个个绘制指令，比如先画背景、再描绘边框......然后将这些指令按顺序组合成一个待绘制列表，用来记录绘制顺序和绘制指令。

![img](https://static001.geekbang.org/resource/image/40/08/40825a55214a7990bba6b9bec6e54108.png?wh=1142*603)





## 6. 栅格化操作

绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。你可以结合下图来看下渲染主线程和合成线程之间的关系：

![img](https://static001.geekbang.org/resource/image/46/41/46d33b6e5fca889ecbfab4516c80a441.png?wh=1142*464)

合成线程首先将图层划分为图块。

![img](https://static001.geekbang.org/resource/image/bc/52/bcc7f6983d5ece8e2dd716f431d0e052.png?wh=1142*995)

因为有些图层很大（比如有的页面使用滚动条滚动好久才能滚到底部），但是通过视口，用户只能看到页面的很小的一部分，这种情况下，要绘制所有图层内容比较浪费性能。

然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。**所谓栅格化，是指将图块转换为位图。**而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的，运行方式如下图所示：

![img](https://static001.geekbang.org/resource/image/d8/20/d8d77356211e12b47bb9f508e2db8520.png?wh=1142*677)

通常，栅格化过程都会使用 GPU 来加速生成，生成的位图被保存在 GPU 内存中。如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的。具体形式你可以参考下图：

![img](https://static001.geekbang.org/resource/image/a8/87/a8d954cd8e4722ee03d14afaa14c3987.png?wh=1142*857)







## 7. 显示

一旦所有图块都被栅格化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。





















[^1]: 这两个步骤是同步进行的。

[^2]: 和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时，会执行一个转换操作。
[^3]: DOM 树中含有很多不可见的元素，比如 head 标签，还有使用了 display:none 属性的元素。所以在显示之前，我们还要额外地构建一棵只包含可见元素布局树。
[^4]: 如果没有分层机制，从布局树直接生成目标图片，那么每次页面有很小的变化，都会触发重排或者重绘，严重影响页面的渲染效率。

