# 浏览器相关知识点

## 1.跨域问题及解决方案

在前后端分离的项目中，实际上会运行在不同的域名上。

如果是在本地开发， 前后端也会分别部署在不同的端口。

这个时候，**前端直接请求后端接口，由于浏览器的同源策略的作用，就会出现所谓的跨域问题。**



如下：前端项目的域名是vue.mayikt.com，浏览器访问这个地址后向api.mayikt.com发送ajax请求，由此出现跨域问题。

![image-20220222103338129](C:\Users\64554\AppData\Roaming\Typora\typora-user-images\image-20220222103338129.png)





### 同源策略

![图片](https://mmbiz.qpic.cn/mmbiz_png/TdGLaSU675g4DAZVKvyibzSibMa3kMOspnmNibvAjsvE13fQJicIQmKvvrcDcib1OibkxvIcCXktPTnsxetoaBKbWbhw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



同源策略是指，浏览器访问的地址由协议、域名、端口等组成，在该页面中向别的地址发送ajax请求时，必须要与浏览器当前访问的地址保持一致。如果不一致的话，则会发生跨域的问题。浏览器触发保护机制，拦截该请求的响应结果。



**解决方案**

### JSONP跨域

**原理：利用 `<script>` 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。**

但是由于`script`、`img`这些带`src`属性的标签，在引入外部资源时，使用的都是`GET`请求。所以`JSONP`也只能使用`GET`发送请求，这也是这种方式已经逐渐被淘汰的原因。



### 代理跨域

代理跨域的实现原理：**同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。**

既然跨域问题是浏览器自己的一种保护措施，那么实际上能够通过在前后端之间加一道代理层来变相进行跨域请求。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/17/1685c5bed77e7788~tplv-t2oaga2asx-watermark.awebp)



#### nginx反向代理

**反向代理**

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffd97d0b1cf15~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

+ **正向代理** 就是客户端向代理服务器发送请求，并且指定目标服务器，之后代理向目标服务器转交并且将获得的内容返回给客户端。服务器并不知道是谁发的请求，比如翻墙。
+ **反向代理** 代理的是服务器，代理会判断请求走向何处，并将请求转交给客户端，客户端只会觉得这个代理是一个真正的服务器。Nginx就是性能非常好的反向代理服务器，用来做负载均衡。



使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。





#### Webpack Server代理

在 webpack 中可以通过配置 proxy 来在浏览器和服务端之间添加代理服务器。本质还是代理跨域。

![图片](https://mmbiz.qpic.cn/mmbiz_png/TdGLaSU675g4DAZVKvyibzSibMa3kMOspnV0aLvp2Eu5E9VkvEuf4ZdNXO1tK0Nchib9rBt9651q8ZCqkmaRmCicSA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

可在前端`webpack.config.js`配置代理：

```js
module.exports = {
  ...
  output: {...},
  devServer: {
    port: 3000,
    proxy: {
      "/api": {
        target: "http://localhost:3001"
      }
    }
  },
  plugins: []
};
```



#### CORS跨域

CORS 其实是 W3C 的一个标准，全称是跨域资源共享。它需要浏览器和服务器的共同支持，具体来说，非 IE 和 IE10 以上支持CORS，服务器需要附加特定的响应头。

请求发出去之前，浏览器会自动在请求头当中，添加一个`Origin`字段，用来说明请求来自哪个`源`。服务器拿到请求之后，在响应头添加`Access-Control-Allow-Origin`字段，如果`Origin`不在这个字段的范围中，那么浏览器就会将响应拦截。



发送请求时出现两种情况，分别为简单请求和复杂请求。

**简单请求：**

+ 请求方法为 GET、POST 或者 HEAD

+ 请求头的取值范围: Accept、Accept-Language、Content-Language、Content-Type(只限于三个值`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`)



简单请求的流程：

<img src="https://mmbiz.qpic.cn/mmbiz_png/TdGLaSU675g4DAZVKvyibzSibMa3kMOspnfXZ8x7UDBCzYVMlJ8sETayDz7Lib3Opcicek9b5z1vC0qfiaZWj8VmRzA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom: 50%;" />





**非简单请求**

1. 非简单请求是那种对服务器有特殊要求的请求，比如请求方法是 PUT 或 DELETE，或者Content-Type字段的类型是application/json
2. 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求





## 2.浏览器存储方式

cookie，localStorage，sessionStorage，indexDB 都是浏览器提供的存储方式。

**什么是cookie？**

+ HTTP是无状态的协议（每次客户端和服务器会话完成时，服务器不会保存任何会话信息，也就是说浏览器浏览了某个网页后，第二次再浏览这个网页，服务器不会发现是同一个客户端）。所以服务器与客户端为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态通过cookie或者session去实现。
+ 在客户端首次向服务器发送请求时，服务器会设置cookie，并且在每次向同一服务器发送请求时都会被携带。

![image-20220222163506981](C:\Users\64554\AppData\Roaming\Typora\typora-user-images\image-20220222163506981.png)



**cookie某些属性的作用？**

| 属性      | 作用                                                         |
| --------- | ------------------------------------------------------------ |
| value     | 如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识 |
| http-only | 不能通过JS访问Cookie，减少XSS攻击                            |
| secure    | 只能在协议为HTTPS的请求中携带                                |
| same-site | 规定浏览器不能在跨域请求中携带Cookie，减少CSRF攻击           |



**四者的区别**

1. cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器间来回传递。而 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。
2. 存储大小限制不同，cookie 数据不能超过4K，因为每次 http 请求都会携带 cookie，所以cookie 只适合保存很小的数据，如会话标识。sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到5M或更大。
3. 数据有效期不同，cookie 在设置的过期时间内一直有效，localStorage 始终有效，sessionStorage 仅在当前会话关闭前有效。
4. 作用域不同，sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 和 cookie 在所有同源窗口中都是共享的。



## 3. Cookie 

**Cookie 简介**

前面说到了 HTTP 是一个无状态的协议，每次 http 请求都是独立、无关的，默认不需要保留状态信息。但有时候需要保存一些状态，怎么办呢？

HTTP 为此引入了 Cookie。Cookie 本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储(在chrome开发者面板的Application这一栏可以看到)。向同一个域名下发送请求，都会携带相同的 Cookie，服务器拿到 Cookie 进行解析，便能拿到客户端的状态。而服务端可以通过响应头中的`Set-Cookie`字段来对客户端写入`Cookie`。



**Cookie 属性**

**生存周期**

Cookie 的有效期可以通过**Expires**和**Max-Age**两个属性来设置。

- **Expires**即`过期时间`
- **Max-Age**用的是一段时间间隔，单位是秒，从浏览器收到报文开始计算。

若 Cookie 过期，则这个 Cookie 会被删除，并不会发送给服务端。

**作用域**

关于作用域也有两个属性: **Domain**和**path**, 给 **Cookie** 绑定了域名和路径，在发送请求之前，发现域名或者路径和这两个属性不匹配，那么就不会带上 Cookie。值得注意的是，对于路径来说，`/`表示域名下的任意路径都允许使用 Cookie。

**安全相关**

如果带上`Secure`，说明只能通过 HTTPS 传输 cookie。

如果 cookie 字段带上`HttpOnly`，那么说明只能通过 HTTP 协议传输，不能通过 JS 访问，这也是预防 XSS 攻击的重要手段。



**Cookie 的缺点**

1. 容量缺陷。Cookie 的体积上限只有`4KB`，只能用来存储少量的信息。
2. 性能缺陷。Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。但可以通过`Domain`和`Path`指定**作用域**来解决。
3. 安全缺陷。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在`HttpOnly`为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。




## 4.cookie和session的异同

1. cookie数据存放在客户的浏览器上，session数据放在服务器上。
2. cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。
3. session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。
4. 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie
5. 可以考虑将登陆信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中。







## 5.会话跟踪的方式

http是无状态的，一次请求结束，连接断开，下次服务器再收到请求，它就不知道这个请求是哪个用户发过来的。当然它知道是哪个客户端地址发过来的，但是对于我们的应用来说，我们是靠用户来管理，而不是靠客户端。所以对我们的应用而言，它是需要有状态管理的，以便服务端能够准确的知道http请求是哪个用户发起的，从而判断他是否有权限继续这个请求。这个过程就是常说的会话管理。

**Cookie：** Cookie是Web服务器发送给客户端的一小段信息，客户端请求时可以读取该信息发送到服务器端，进而进行用户的识别。对于客户端的每次请求，服务器都会将Cookie发送到客户端,在客户端可以进行保存,以便下次使用。

**session：**用户第一次访问的时候，在服务器端会创建一个session对象，在session中可以存放信息。并且产生一个sessionID来标识这个session对象，然后将这个sessionID放入到Cookie中发送到客户端。这样当用户第二次及以后向服务器发送请求的时候，就会通过cookie把sessionid传回给服务器，以便服务器能够根据sessionid找到与该用户对应的session对象。

**token：**用户第一次访问的时候，将用户信息作数字签名，加密之后得到token，并返回给客户端，后续请求携带token，这样服务器对token作解密和签名认证后拿到其中的用户信息进行有效性判断。

**JWT：**JSON Web Token，一种成熟的 token 字符串生成方案。

+ 服务器认证以后，生成一个加了签名的 JSON 对象，发回给客户端      
+ 此后，客户端每次与服务器通信，都带上这个 JWT。可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息Authorization字段里面{ Authorization: Bearer <token> }



## 7.Service Worker

+ Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。
+ Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。





## 6.Doctype作用?严格模式与混杂模式如何区分？它们有何意义?

+ Doctype声明于文档最前面，告诉浏览器以何种方式来渲染页面，这里有两种模式，严格模式和混杂模式。
+ **严格模式** 的排版和JS 运作模式是 以该浏览器支持的最高标准运行。
+ **混杂模式**，向后兼容，模拟老式浏览器，防止浏览器无法兼容页面。





































































































































































