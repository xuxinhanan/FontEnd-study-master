# 浏览器相关知识点



## 2.浏览器存储方式

cookie，localStorage，sessionStorage，indexDB 都是浏览器提供的存储方式。

**什么是cookie？**

+ HTTP是无状态的协议（每次客户端和服务器会话完成时，服务器不会保存任何会话信息，也就是说浏览器浏览了某个网页后，第二次再浏览这个网页，服务器不会发现是同一个客户端）。所以服务器与客户端为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态通过cookie或者session去实现。
+ 在客户端首次向服务器发送请求时，服务器会设置cookie，并且在每次向同一服务器发送请求时都会被携带。

![image-20220222163506981](C:\Users\64554\AppData\Roaming\Typora\typora-user-images\image-20220222163506981.png)







**四者的区别**

1. cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器间来回传递。而 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。
2. 存储大小限制不同，cookie 数据不能超过4K，因为每次 http 请求都会携带 cookie，所以cookie 只适合保存很小的数据，如会话标识。sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到5M或更大。
3. 数据有效期不同，cookie 在设置的过期时间内一直有效，localStorage 始终有效，sessionStorage 仅在当前会话关闭前有效。
4. 作用域不同，sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 和 cookie 在所有同源窗口中都是共享的。



## 3. Cookie 

**Cookie 简介**

前面说到了 HTTP 是一个无状态的协议，每次 http 请求都是独立、无关的，默认不需要保留状态信息。但有时候需要保存一些状态，怎么办呢？

HTTP 为此引入了 Cookie。Cookie 本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储(在chrome开发者面板的Application这一栏可以看到)。向同一个域名下发送请求，都会携带相同的 Cookie，服务器拿到 Cookie 进行解析，便能拿到客户端的状态。而服务端可以通过响应头中的`Set-Cookie`字段来对客户端写入`Cookie`。



**Cookie 属性**

**生存周期**

Cookie 的有效期可以通过 **Expires** 和 **Max-Age** 两个属性来设置。

- **Expires**即`过期时间`
- **Max-Age**用的是一段时间间隔，单位是秒，从浏览器收到报文开始计算。

若 Cookie 过期，则这个 Cookie 会被删除，并不会发送给服务端。

**作用域**

关于作用域也有两个属性: **Domain**和**path**, 给 **Cookie** 绑定了域名和路径，在发送请求之前，发现域名或者路径和这两个属性不匹配，那么就不会带上 Cookie。值得注意的是，对于路径来说，`/`表示域名下的任意路径都允许使用 Cookie。

**安全相关**

如果带上`Secure`，说明只能通过 HTTPS 传输 cookie。

如果 cookie 字段带上`HttpOnly`，那么说明只能通过 HTTP 协议传输，不能通过 JS 访问，这也是预防 XSS 攻击的重要手段。



**Cookie 的缺点**

1. 容量缺陷。Cookie 的体积上限只有`4KB`，只能用来存储少量的信息。
2. 性能缺陷。Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。但可以通过`Domain`和`Path`指定**作用域**来解决。
3. 安全缺陷。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在`HttpOnly`为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。




## 4.cookie和session的异同

1. cookie数据存放在客户的浏览器上，session数据放在服务器上。
2. cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。
3. session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。
4. 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie
5. 可以考虑将登陆信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中。







## 5.会话跟踪的方式

http是无状态的，一次请求结束，连接断开，下次服务器再收到请求，它就不知道这个请求是哪个用户发过来的。当然它知道是哪个客户端地址发过来的，但是对于我们的应用来说，我们是靠用户来管理，而不是靠客户端。所以对我们的应用而言，它是需要有状态管理的，以便服务端能够准确的知道http请求是哪个用户发起的，从而判断他是否有权限继续这个请求。这个过程就是常说的会话管理。

**Cookie：** Cookie是Web服务器发送给客户端的一小段信息，客户端请求时可以读取该信息发送到服务器端，进而进行用户的识别。对于客户端的每次请求，服务器都会将Cookie发送到客户端,在客户端可以进行保存,以便下次使用。

**session：**用户第一次访问的时候，在服务器端会创建一个session对象，在session中可以存放信息。并且产生一个sessionID来标识这个session对象，然后将这个sessionID放入到Cookie中发送到客户端。这样当用户第二次及以后向服务器发送请求的时候，就会通过cookie把sessionid传回给服务器，以便服务器能够根据sessionid找到与该用户对应的session对象。

**token：**用户第一次访问的时候，将用户信息作数字签名，加密之后得到token，并返回给客户端，后续请求携带token，这样服务器对token作解密和签名认证后拿到其中的用户信息进行有效性判断。

**JWT：**JSON Web Token，一种成熟的 token 字符串生成方案。

+ 服务器认证以后，生成一个加了签名的 JSON 对象，发回给客户端      
+ 此后，客户端每次与服务器通信，都带上这个 JWT。可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息Authorization字段里面{ Authorization: Bearer <token> }



## 7.Service Worker

+ Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。
+ Service Worker 实现缓存功能一般分为三个步骤：
  + 首先需要先注册 Service Worker，
  + 然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。









































































































































































