### 当运行一个Node.js应用程序时发生了什么？

当我们在计算机上使用Node的时候，意味着有一个Node进程在那台电脑上运行（node是基于C++的程序，因此它在运行时将启动一个进程）（因此我们实际上可以访问一个进程变量process）。

在这个过程中，node.js运行在单线程中（无论你有10个用户还是1000万个用户同时访问你的应用程序）。

当运行一个Node.js应用程序时发生了什么？

1. 程序初始化
2. 执行所有顶层代码（所有不在回调函数里面的代码）
3. 获取所有模块
4. 注册回调（事件处理程序）
5. 开始事件循环[^1]



### 线程池

此外，有些任务太重了而无法在事件循环中执行，因为他们会阻塞线程。因此需要用到**线程池**。

线程池和事件循环一样是Libuv库提供给node.js的，线程池为我们提供了四个额外的线程。

事件循环自动将繁重的任务卸载到线程池中（这个NODE内部自动决定的，开发人员无法决定）。这些任务包括：

+ 文件系统API
+ 加密模块相关
+ 压缩文件相关
+ DNS查询





### Node.js 的核心模式 —— reactor 模式了（又称事件驱动）

reactor模式运作如下：

![image-20220711234123344](C:\Users\64554\AppData\Roaming\Typora\typora-user-images\image-20220711234123344.png)



1. 应用程序向事件多路分离器提交非阻塞 I/O 请求，提交的时候还要指定 Handler 事件处理程序。
2. 事件多路分离器执行完 I/O 操作后，会向事件队列推送相应的事件。
3. 此时，事件循环会迭代事件队列中的各项事件。
4. 并针对每项事件触发与之相关的 handler。
5. 这个 Handler 是应用程序的一部分，它在执行完自己的逻辑后，把**控制权返还给事件循环**（图中的5a）。并且在 Handler 执行过程中，它也可能会提出新的异步操作请求（图中的5b），从而向事件多路分离器提交新的请求。
6. 事件循环把事件队列的所有事件处理完毕后，事件循环会阻塞于事件多路分离器这里（由于单线程，参考上一节伪代码），直到新的事件出现。

+ 如果事件分离器已经没有操作需要处理（通常一个WEB服务器项目需要一直监听HTTP请求因此会一直运行），而且事件队列之中也没有待处理的事件，那么 Node.js 应用程序将会退出。



总结：reactor 模式把每项 I/O 操作都同某个事件处理程序( callback 函数 )关联起来，只要事件循环处理某个事件，handler 就会触发。 



----------

#### 事件循环一个tick周期的几个阶段

每个阶段都有一个回调队列，来自事件循环接收到的事件回调。

1. 第一阶段：到期的定时器回调（如果在其他阶段到期，那么会在下一个tick周期的第一阶段执行回调）
2. 第二阶段：I/O操作（在这个阶段我们的大部分代码被执行，因为一个典型的node程序大部分事情都与网络和文件访问有关）
3. 第三阶段：setImmediate回调
4. 第四阶段：关闭回调（不重要）

接下来Node检查是否还有未到期的定时器或仍在后台运行的 I/O 任务，如果没有则退出应用程序；否则继续运行事件循环到达下一个tick。



此外还有微任务队列：nexttick和 promise，他们会在当前阶段后立即执行。





#### 事件驱动架构

比如创建一个http server后通过server.on('request', callback)为'request'事件创建一个侦听器。假设服务器正在运行，当客户端访问url后发出事件，于是侦听器监听到'request'事件后将自动调用事件回调并将一些数据发送给客户端。









[^1]: 事件循环是你的应用程序完成大部分工作的地方。

