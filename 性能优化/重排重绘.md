## 重排

渲染线程在构建好 DOM 树时，并不包含位置信息。计算这些值的过程称为**布局（Layout）** 或 **重排（Reflow）**。

## 重绘

重排后，浏览器会重新绘制受影响的部分到屏幕可视区域，该过程称为[重绘](https://tsejx.github.io/javascript-guidebook/browser-object-model/browser-working-principle/paint#重绘)。另外，DOM 变化不一定都会影响几何属性，比如改变一个元素的背景色不影响宽高，这种情况下只会发生重绘，代价较小。

## 绘制

绘制工作是使用用户界面基础组件完成的。你所看见的一切都会触发 `paint`。包括拖动滚动条，鼠标选择中文字等这些完全不改变样式，只改变显示结果的动作都会触发 `paint`。

`paint` 的工作就是把文档中用户可见的那一部分展现给用户。`paint` 是把 `layout` 和样式计算的结果直接在浏览器视窗上绘制出来，它并不实现具体的元素计算，只是 `layout` 后面的那一步。

## 浏览器的优化策略

如果布局是由 **大小调整** 或 **位置改变** 而触发的，那么可以从缓存中获取渲染器的大小，而无需重新计算。

在某些情况下，只有一个子树进行了修改，因此无需从根节点开始布局。这适用于在本地进行更改而不影响周围元素的情况，例如在文本字段中插入文本（否则每次键盘输入都将触发从根节点开始的布局）。

因为这个优化方案，所以你每改一次样式，它就不会回流（Reflow）或重绘（Repaint）一次。

**但是有些情况，如果我们的程序需要某些特殊的值，那么浏览器需要返回最新的值，而会有一些样式的改变，从而造成频繁的重排和重绘。**比如获取下面这些值，浏览器会马上进行重排：

- `offsetTop`、`offsetLeft`、`offsetWidth`、`offsetHeight`
- `scrollTop`、`scrollLeft`、`scrollWidth`、`scrollHeight`
- `clientTop`、`clientLeft`、`clientWidth`、`clientHeight`
- `window.getComputedStyle()`
- `currentStyle`



## 减少重排的优化策略

- 缓存 DOM 节点，供后面使用
- 有动画的 DOM 使用 `fixed` 或 `absoult` 的 `position`，脱离文档流



















