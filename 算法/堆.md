堆是一种特殊的树。

+ 堆是一个完全二叉树
+ 堆中每一个节点的值都必须大于等于（或小于等于）其子树每个节点的值



**如何实现一个堆？**

完全二叉树适合用数组来存储。用数组来存储完全二叉树非常节省存储空间。因为不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。数组中下标为 i 的左子节点下标为 i * 2 的节点，右子节点是下标为 i * 2 + 1 的节点。父节点就是下标为 i/2 的节点。

![img](https://static001.geekbang.org/resource/image/4d/1e/4d349f57947df6590a2dd1364c3b0b1e.jpg)





堆化（ heapify ）：对堆中元素进行调整，使其满足堆的特性。

**顺着节点所在的路径，向上或者向下，对比，然后交换**。

~~~js
function heapifyUp(heap, indexThis, heapSize) {
    while (true) {
        let minPos = indexThis;
        if (indexThis * 2 <= heapSize && heap[indexThis] > heap[indexThis * 2]) minPos = indexThis * 2;
        if (indexThis * 2 + 1 <= heapSize && heap[minPos] > heap[indexThis * 2 + 1]) minPos = indexThis * 2 + 1;
        if (minPos == indexThis) break;
        swap(heap,indexThis, minPos);
        indexThis = minPos;
    }
}
~~~



**如何基于堆实现排序？**

堆排序的过程大致可以分为：建堆和排序。

**建堆**：**从后往前处理数组，并且每个数据都从上往下堆化。**因此，从第一个非叶子节点开始处理（即n / 2），因为叶子节点往下堆化只能自己跟自己比较。

~~~js
function buildMinHeap(arr) {
    let size = arr.length - 1;
    for (let i = Math.floor(size/2); i >= 1; --i){
        heapifyUp(arr,i,size);
    }
}
~~~



排序：建堆完成后，数组中的数据已经按照大顶堆的特性来组织了。于是把堆顶也就是最大的元素放到下标为 n 的位置。然后对剩下 n - 1 个元素重新堆化（实际上只需要对交换上来的堆顶元素堆化，其他元素保持堆的特性，无需调整）并取堆顶放到 n - 1 的位置....

![img](https://static001.geekbang.org/resource/image/23/d1/23958f889ca48dbb8373f521708408d1.jpg)



~~~js
function sort(arr) {
    let size = arr.length - 1;
    buildMinHeap(arr);
    let k = size;
    while (k > 1) {
        swap(arr, 1, k);
        --k;
        heapifyUp(arr, 1, k);
    }
}
~~~



**排序的时间复杂度**

依次将堆顶元素和最后的元素做交换，然后只需对堆顶元素做一次调整（其他层元素保持着堆的性质，无需调整），时间复杂度为树的深度O(log(n))，调整时范围只到倒数第二个元素（认为最后一个元素已不属于堆，下次交换后，调整范围只到倒数第三个元素，认为倒数第二个元素已不属于堆，依次类推）。综上，需要调整O(n)次。



**堆的应用**

1. 优先级队列
2. 利用堆求 Top K
3. 利用两个堆求动态数据的中位数









