> :heavy_exclamation_mark::heavy_exclamation_mark: 归并排序算法是稳定的排序算法，时间复杂度是 O(nlogn)。但它存在致命的缺点，即归并排序不是原地排序算法，空间复杂度比较高，是 O(n)[^1]。



先看归并算法的核心思想，如果要排序一组数据：

:one: 先把数组从中间分成前后两部分，然后对前后两部分分别排序；

:two: 再将排好序的两部分合并在一起，这样整个数组就都有序了。

![img](https://static001.geekbang.org/resource/image/db/2b/db7f892d3355ef74da9cd64aa926dc2b.jpg?wh=1142*914)

-------

归并排序使用的就是分治思想，而分治算法一般都是用递归来实现的。

~~~js
// 递推公式：
mergeSort(p…r) = merge(mergeSort(p…q), mergeSort(q+1…r))

// 终止条件：
p >= r // 不用再继续分解
~~~

归并排序模板：

~~~js
// 递归调用函数
mergeSort(A, p, r) {
  // 递归终止条件
  if (p >= r) return

  // 取p到r之间的中间位置q
  q = (p + r) / 2
  // 分治递归
  mergeSort(A, p, q)
  mergeSort(A, q+1, r)
  // 将A[p...q]和A[q+1...r]合并为A[p...r]
  merge(A[p...r], A[p...q], A[q+1...r])
}
~~~

## 合并函数

合并函数 merge()的作用就是，将已经有序的 A[p...q] 和 A[q+1....r]合并成一个有序的数组，并且放入 A[p....r]。那这个过程具体该如何做呢？

+ 我们申请一个临时数组 tmp，大小与 A[p...r]相同
+ 用两个游标 i 和 j，分别指向 A[p...q]和 A[q+1...r]的第一个元素。比较这两个元素 A[i]和 A[j]，
+ 如果 A[i]<=A[j]，我们就把 A[i]放入到临时数组 tmp，并且 i 后移一位，
+ 否则将 A[j]放入到数组 tmp，j 后移一位。

核心就是两两比较，然后按大小将所有元素都放进临时数组里。

最后再把临时数组 tmp 中的数据拷贝到原数组 A[p...r]中。

![img](https://static001.geekbang.org/resource/image/95/2f/95897ade4f7ad5d10af057b1d144a22f.jpg?wh=1142*856)





[^1]: 因为合并函数中需要申请临时内存空间。

