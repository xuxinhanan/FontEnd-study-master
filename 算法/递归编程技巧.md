

> **:heavy_exclamation_mark: 递归是一种编程技巧。**



> **:heavy_exclamation_mark: 递归的实现依赖一个栈结构，称为递归调用栈。**



递归过程：

~~~js
1 + sum[2, 3, 4, 5, 6, 7, 8, 9]
1 + 2 + sum[3, 4, 5, 6, 7, 8, 9]
1 + 2 + 3 + sum[4, 5, 6, 7, 8, 9]
1 + 2 + 3 + 4 + sum[5, 6, 7, 8, 9]
1 + 2 + 3 + 4 + 5 + sum[6, 7, 8, 9]
1 + 2 + 3 + 4 + 5 + 6 + sum[7, 8, 9]
1 + 2 + 3 + 4 + 5 + 6 + 7 + sum[8, 9]
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + sum[9]
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + sum[] 
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 0  -> 「满足终止条件时，释放堆栈返回结果」
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 
1 + 2 + 3 + 4 + 5 + 6 + 7 + 17 
1 + 2 + 3 + 4 + 5 + 6 + 24 
l + 2 + 3 + 4 + 5 + 30 
1 + 2 + 3 + 4 + 35 
1 + 2 + 3 + 39 
1 + 2 + 42 
1 + 44 
45
~~~



## 递归实现需要满足三个条件



1. **一个问题的解可以分解为几个子问题的解**
2. **这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样**
3. **存在递归终止条件**



## **如何编写递归代码？**

> :heavy_exclamation_mark::heavy_exclamation_mark:  **写递归代码的关键[^1]就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式[^2]，然后再推敲终止条件[^3]，最后将递推公式和终止条件翻译成代码。**





## 递归的缺点

函数调用自己时会创建新的函数上下文。所以**效率低下或者不正确的递归调用**，例如永远无法满足结束条件，或者用效率低下的递归来遍历巨大的数组，很容易导致 **「栈溢出」**。

如何解决呢？可采用 **「记忆化递归」** 或者 **「尾递归优化」**。



### 记忆化递归避免重复计算

递归是将任务分解成更小版本的自己的机制。通常情况下，每次递归调用都在一个更小的子集解决“同样的问题”，直至达到递归的终止条件，然后释放堆栈返回结果。在这个过程中，就可能出现重复计算的情况，如下图所示：

<img src="https://static001.geekbang.org/resource/image/e7/bf/e7e778994e90265344f6ac9da39e01bf.jpg" alt="img" style="zoom:50%;" />



:white_check_mark: **因此如果每一个子任务的结果都能缓存， 就可以减少重复同样的计算， 从而提高性能。**



为此，我们可以通过一个数据结构（比如数组）来保存已经求解过的 f(k)。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从数组中取值返回，不需要重复计算。





### 尾递归优化

当使用尾递归时，JavaScript 编译器有可能帮助你做**「尾部调用优化」**（TCO）。TCO 是 ES6 添加的编译器增强功能。

**函数的最后一件事情如果是递归的函数调用，那么运行时会认为不必要保持当前的栈帧，因为所有工作已经完成，完全可以抛弃当前帧。**

在大多数情况下，只有将函数的上下文状态作为参数传递给下一个函数调用，（如在递归阶乘函数处看到的），才能使递归调用不需要依赖当前帧。通过这种方式，递归每次都会创建一个新的帧，回收旧的帧，而不是将新的帧叠在旧的上。



![image-20220617153736926](C:\Users\64554\AppData\Roaming\Typora\typora-user-images\image-20220617153736926.png)













[^1]: 只要遇到递归，我们就把它抽象成一个递推公式，并推敲终止条件，千万不要去想一层层的调用关系，不要试图用人脑取分解递归的每个步骤。

[^2]: 递推公式的主体是：处理函数调用「小于原始输入」的一组输入。如果输入不变小，那么递归就会无限期地运行，直至程序崩溃。随着函数的递归，输入会无条件地变小，最终到达触发终止条件，以一个值作为递归过程的终止。
[^3]: 终止条件是能够令递归函数计算出具体结果的一组输入，而不必再重复下去。
[^4]: 调试递归的方式：打印输入递归值或结合条件断点调试。

