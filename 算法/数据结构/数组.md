> :heavy_exclamation_mark::heavy_exclamation_mark: 数组是一种 **线性表** 数据结构。它用一组 **连续的内存空间**，来存储一组数据。



### :white_check_mark:**「线性表」**

顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。除了数组，链表、队列、栈等也是线性表结构。

![img](https://static001.geekbang.org/resource/image/b6/77/b6b71ec46935130dff5c4b62cf273477.jpg?wh=1142*833)

而与它相对立的概念是**非线性表**，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。

![img](https://static001.geekbang.org/resource/image/6e/69/6ebf42641b5f98f912d36f6bf86f6569.jpg?wh=1142*727)

--------

### :white_check_mark:**「连续的内存空间」**

正是因为这个限制，它才有了一个堪称“杀手锏”的特性：**“随机访问”**[^1]。但有利就有弊，这个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。

----

### :white_check_mark: 低效的“插入”和“删除”

数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效。

例如插入操作。

假设数组的长度为 n，现在，如果我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k～n 这部分的元素都顺序地往后挪一位。所以平均情况时间复杂度为O(n)。

再来看删除操作。

跟插入数据类似，如果我们要删除第 k 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。平均情况时间复杂度也为 O(n)。

--------------

### :white_check_mark: 插入优化技巧 —— 交换

如果数组中的数据是有序的，我们在某个位置插入一个新的元素时，就必须按照刚才的方法搬移 k 之后的数据。

但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，就可以利用元素交换技巧。例如：

+ [283. 移动零](https://leetcode.cn/problems/move-zeroes/)

+ 快排的分区函数

---------

-----------

--------

:white_check_mark: 删除优化技巧 —— 合并删除操作

实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率是不是会提高很多呢？

我们继续来看例子。数组 a[10]中存储了 8 个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除 a，b，c 三个元素。为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。

![img](https://static001.geekbang.org/resource/image/b6/e5/b69b8c5dbf6248649ddab7d3e7cfd7e5.jpg?wh=1142*311)

如果你了解 JVM，你会发现，这不就是 JVM 标记清除垃圾回收算法的核心思想吗？









[^1]: 数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。

