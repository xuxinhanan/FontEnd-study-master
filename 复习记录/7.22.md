#### [73. 矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/) ####

#### [78. 子集](https://leetcode.cn/problems/subsets/)

备忘录去重：去的是重复元素

选择列表去重：去的是逆序结果，如  [1, 2] -- [2, 1]

 

#### [79. 单词搜索](https://leetcode.cn/problems/word-search/)

要求在2D表中搜索满足给定单词的字符组合。

起始位置不确定，需要扫描二维数组，找到字符跟给定单词的第一个字符相同的元素位置，并进行 dfs 搜索，如果任一方向满足条件，则返回结果；否则，返回 false。



+ DFS 过程中，要记录已经访问过的节点，防止重复遍历，这里用 `board[row][col] = null` 表示当前已经访问过

+ 是否匹配当前单词中的字符，不符合回溯，这里记得把当前 `board[row][col]` 还原

#### [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/) #####

递归隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来。

中序遍历即，先将所有左子节点推入栈中，栈顶元素即二叉树左叶子节点，将其从栈中弹出，记录其结果，并以该节点为根，遍历其右子树。



#### [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)

这是一个经典的使用分治思路的题目。

对于数字 n ，我们可以分成左右两部分。我们不妨设其分别为 A 和 B。那么问题转化为 A 和 B 所能组成的 BST 的数量的笛卡尔积。**而对于 A 和 B 以及原问题除了规模，没有不同，这不就是分治思路么？**至于此，我们只需要考虑边界即可，**边界很简单就是 n 小于等于 1 的时候，我们返回 1。**

具体来说：

+ 我们遍历一次[1, n]的数组。对于每一项，我们都假设其是断点。断点左侧的是 A，断点右侧的是 B

+ 那么 A 就是 i - 1 个数， 那么 B 就是 n - i 个数

+ 于是递归，并将 A 和 B 的结果相乘即可



~~~js
// 构造二维数组的方法
let memo = new Array(n + 1).fill(0).map(() =>new Array(n + 1).fill(0));
~~~

