

# 0.设计模式的核心思想——封装变化

这一点相信大家不难理解——如果说我们写一个业务，这个业务是一潭死水，初始版本是 1.0，100 年后还是 1.0，不接受任何迭代和优化，那么这个业务几乎可以随便写。反正只要实现功能就行了，完全不需要考虑可维护性、可扩展性。

但在实际开发中，不发生变化的代码可以说是不存在的。我们能做的只有将这个变化造成的影响**最小化** —— **将变与不变分离，确保变化的部分灵活、不变的部分稳定**。

这个过程，就叫“封装变化”；这样的代码，就是我们所谓的“健壮”的代码，它可以经得起变化的考验。而设计模式出现的意义，就是帮我们写出这样的代码。

无论是创建型、结构型还是行为型，这些具体的设计模式都是在用自己的方式去封装不同类型的变化 —— 创建型模式封装了创建对象过程中的变化，比如下节的工厂模式，它做的事情就是将创建对象的过程抽离；结构型模式封装的是对象之间组合方式的变化，目的在于灵活地表达对象间的配合与依赖关系；而行为型模式则将是对象千变万化的行为进行抽离，确保我们能够更安全、更方便地对行为进行更改。



# 1. 观察者模式

> 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。

![image-20220127110751274](https://windliangblog.oss-cn-beijing.aliyuncs.com/windliangblog.oss-cn-beijing.aliyuncs.comimage-20220127110751274.png)



## 实现

观察者模式的实现实际上就是使用回调模式，当状态变更时，调用回调通知观察者。

~~~js
class Subject {
  constructor() {
    this.observers = [];
  }

  attach(observer) {
    this.observers.push(observer);
  }

  detach(observer) {
    this.observers.forEach((item, i) => {
      if (item === observer) {
        this.observers.splice(i, 1);
      }
    });
  }

  notify() {
    this.observers.forEach((observer) => {
      observer.update(this);
    });
  }
}

class observer {
  constructor() {}

  update() {
    console.log("Observer update");
  }
}

/* 使用 */
class subSubject extends Subject {
  constructor() {
    super();
    this.state = null;
    this.observers = [];
  }

  getState() {
    return this.state;
  }

  setState(newState) {
    this.state = newState;
    this.notify();
  }
}

class subObserver extends Observer {
  constructor() {
    super();
    this.state = null;
  }

  // 重写一个具体的update方法
  update(subject) {
    this.state = subject.getState();
    this.work();
  }

  work() {
    console.log("state change callbackFn");
  }
}
~~~

## 应用

假设我们拿到请求得到的数据后，有多个模块添加了回调。如果什么都不考虑可能会直接这样写：

~~~js
// getAddress 异步请求
// 有三个模块 A，B，C 依赖请求的结果

getAddress().then(res => {
  const address = res.address;
  A.update(address)
  B.next(address)
  C.change(address)
})
~~~

此时如果多了一个模块 `D` ，同样需要拿到请求结果后进行下一步操作，我们只好去翻请求的代码把 `D` 模块的调用补上。

~~~js
getAddress().then(res => {
  const address = res.address;
  A.update(address)
  B.next(address)
  C.change(address)
  D.init(address)
})
~~~

可以看到各个模块和获取地址模块耦合严重，`A`、`B`、`C` 模块有变化或者有新增模块，都需要深入到获取地址的代码去修改。

根据观察者模式的思想代码可以这样写：

~~~js
const observers = []
// 注册观察者
observers.push(A.update)
observers.push(B.next)
obervers.push(C.change)

getAddress().then(res => {
  const address = res.address;
  observers.forEach(update => update(address))
})
~~~

可以看到，通过观察者模式的思想我们将添加回调的操作解耦了出来。





# 2. 发布订阅模式

观察者模式中，`Subject` **直接触及到订阅者**（自己维护观察者列表进行注册和通知）。

![image-20220130170413954](https://windliangblog.oss-cn-beijing.aliyuncs.com/windliangblog.oss-cn-beijing.aliyuncs.comimage-20220130170413954.png)

发布订阅模式则是**不直接触及到订阅者、而是由统一的第三方来完成实际的通信的操作**。

![image-20220130171806687](https://windliangblog.oss-cn-beijing.aliyuncs.com/windliangblog.oss-cn-beijing.aliyuncs.comimage-20220130171806687.png)





## 实现一个事件总线 mitt / eventBus

mitt 的使用：

1. 创建一个 mitt

~~~js
import mitt from 'mitt'

const emitter = mitt()
~~~

2. 订阅事件

```javascript
emitter.on('foo', callback)
```

3. 发布事件

```javascript
// params 指事件被触发时回调函数接收的入参
emitter.emit('foo', params)
```



函数式实现：

~~~js
function mitt() {
  const handlers = {};
  return {
    handlers,

    on(eventName, callback) {
      if (!handlers[eventName]) {
        handlers[eventName] = [];
      }
      handlers[eventName].push(callback);
    },

    emit(eventName, ...args) {
      if (handlers[eventName]) {
        handlers[eventName].slice().forEach((callback) => callback(...args));
      }
    },

    off(eventName, callback) {
      const handlersQueue = handlers[eventName];
      const index = handlersQueue.indexOf(callback);
      if (index !== -1) {
        handlersQueue.splice(index, 1);
      }
    },

    once(eventName, callback) {
      const onceCallback = (...args) => {
        callback(...args);
        this.off(eventName, onceCallback);
      };
      this.on(eventName, onceCallback);
    },
  };
}
~~~



类实现：

~~~js
class Mitt {
  constructor() {
    // handler 是一个事件和回调之间的映射表
    this.handlers = {};
  }

  // on方法用于安装事件监听器
  on(eventName, callback) {
    if (!this.handlers[eventName]) {
      this.handlers[eventName] = [];
    }
    this.handlers[eventName].push(callback);
  }

  // emit方法用于触发目标事件
  emit(eventName, ...args) {
    if (this.handlers[eventName]) {
      this.handlers[eventName].slice().forEach((callback) => callback(...args));
    }
  }

  // 移除某个事件回调队列里的指定回调函数
  off(eventName, callback) {
    const handlers = this.handlers[eventName];
    const index = handlers.indexOf(callback);
    if (index !== -1) {
      handlers.splice(index, 1);
    }
  }

  // 为事件注册单次监听器
  once(eventName, callback) {
    // 对回调函数进行包装，使其执行完毕自动被移除
    const onceCallback = (...args) => {
      callback(...args);
      this.off(eventName, onceCallback);
    };
    this.on(eventName, onceCallback);
  }
}
~~~

## 与观察者模式对比

观察者模式，解决的其实是模块间的耦合问题，有它在，即便是两个分离的、毫不相关的模块，也可以实现数据通信。但观察者模式仅仅是减少了耦合，**并没有完全地解决耦合问题**——被观察者必须去维护一套观察者的集合，这些观察者必须实现统一的方法供被观察者调用。



发布-订阅模式，则是发布者完全不用感知订阅者，不用关心它怎么实现回调方法，事件的注册和触发都发生在独立于双方的第三方平台（事件总线）上。在发布-订阅模式下，实现了完全地解耦。



**但这并不意味着，发布-订阅模式就比观察者模式“高级”。**在实际开发中，我们的模块解耦诉求并非总是需要它们完全解耦，因此需灵活运用。







# 3. 迭代器模式

> 在面向对象编程中，**迭代器模式**是一种设计模式，其中迭代器用于遍历容器并访问容器中的元素。迭代器模式将算法与容器解耦。

1. ES6的迭代器是指实现了 Symbol.iterator 方法的对象，当使用 for..of 循环时会调用这个方法返回一个迭代器—— 一个有 next 方法的对象。

   当希望迭代获取下一个元素时，就调用 `next()` 方法。

   `next()` 方法返回的结果是 `{done: Boolean, value: any}`，当 `done=true` 时，表示循环结束。

2. 通过生成器能使我们能够写出更短的迭代代码。

   执行一个生成器，就得到了一个迭代器。

ES5实现生成器：

~~~js
function generator(list) {
  let idx = 0;
  let len = list.length;
  return {
    next: function () {
      let done = idx >= len;
      let value = !done ? list[idx++] : undefined;
      return {
        done: done,
        value: value,
      };
    },
  };
}

let iterator = generator(["1", "2", "3"]);
console.log(iterator.next());
console.log(iterator.next());
console.log(iterator.next());
console.log(iterator.next());
~~~





# 4. 策略模式

> 策略模式作为一种软件设计模式，指对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。比如每个人都要“交个人所得税”，但是“在中国交个人所得税”和“在美国交个人所得税”就有不同的算税方法。
>
> 策略模式：
>
> - 定义了一族算法（业务规则）；
> - 封装了每个算法；
> - 这族的算法可互换代替（interchangeable）。

## 场景

进入一个营销活动页面，会根据后端下发的不同 `type` ，前端页面展示不同的弹窗。对于这个需求，可以提炼出以下状态映射表。

~~~
STYLE_TYPE.Reward - openMoneyPop()
STYLE_TYPE.Poster - openPosterPop()
STYLE_TYPE.Activity - openActivityPop()
STYLE_TYPE.Balance - openBalancePop()
STYLE_TYPE.Cash - openCashBalancePop()
~~~

于是我们可以很快的写出以下代码完成需求：

~~~js
async getMainData() {
  try {
    const res = await activityQuery(); // 请求后端数据
    this.styleType = res.styleType;
    if (this.styleType === STYLE_TYPE.Reward) {
      this.openMoneyPop();
    }else if (this.styleType === STYLE_TYPE.Waitreward) {
      this.openShareMoneyPop();
    } else if (this.styleType === STYLE_TYPE.Poster) {
      this.openPosterPop();
    } else if (this.styleType === STYLE_TYPE.Activity) {
      this.openActivityPop();
    } else if (this.styleType === STYLE_TYPE.Balance) {
      this.openBalancePop();
    } else if (this?.styleType === STYLE_TYPE.Cash) {
      this.openCashBalancePop();
    }
  } catch (error) {
    log.error(MODULENAME, '主接口异常', JSON.stringify(error));
  }
}
~~~

我们一起来看看这么写代码会带来什么后果：

- 首先，它违背了“单一功能”原则。一个 function 里面，处理了四坨逻辑。这样会带来的糟糕后果：比如说万一其中一行代码出了 Bug，那么整个`getMainData`逻辑都会崩坏；与此同时出了 Bug 你很难定位到底是哪个代码块坏了事；再比如说单个能力很难被抽离复用等等。
- 不仅如此，它还违背了“开放封闭”原则。即实现“对扩展开放，对修改封闭”的效果。假如未来新增一种弹窗类型的话，我们需要到 `getMainData` 内部去补一个 `else if`。

接下来采用策略模式优化代码。

我们仔细想想，上面用了这么多 if-else，是不是就是为了把 `STYLE_TYPE-弹窗函数` 这个映射关系给明确下来？那么在 JS 中，有没有什么既能够既帮我们明确映射关系，同时不破坏代码的灵活性的方法呢？答案就是**对象映射**！

~~~js
// 📁 popTypes.js
import { SHARETYPE } from './constant';

/* 对扩展开放 */
const popTypes = {
  /* 单一功能改造，一个函数对应一个功能 */
  [STYLE_TYPE.Reward]: function() {
    ...
  },
  [STYLE_TYPE.Waitreward]: function() {
    ...
  },
  [STYLE_TYPE.Poster]: function() {
    ...
  },
  [STYLE_TYPE.Activity]: function() {
    ...
  },
  [STYLE_TYPE.Balance]: function() {
    ...
  },
  [STYLE_TYPE.Cash]: function() {
    ...
  },
}

/* 对修改封闭 */
export function openPop(type){
  return popTypes[type]();
}
~~~



```js
// 📁 main.js
import { openPop } from './popTypes';

async getMainData() {
  try {
    const res = await activityQuery(); // 请求后端数据
    openPop(res.styleType);
  } catch (error) {
    log.error(MODULENAME, '主接口异常', JSON.stringify(error));
  }
}
```



## 总结

当出现很多 `if else` 或者 `switch` 的时候，我们就可以考虑是否能使用策略模式了。

通过策略模式，我们可以把臃肿的代码精简。并实现更好的复用性。



# 5. 单例模式

> **保证一个类仅有一个实例，并提供一个访问它的全局访问点**，这样的模式就叫做单例模式。

![image-20220206181649135](https://windliangblog.oss-cn-beijing.aliyuncs.com/windliangblog.oss-cn-beijing.aliyuncs.comimage-20220206181649135.png)

用ES6模拟一下：

~~~js
class Singleton {
  static getInstance() {
    if (!Singleton.instance) {
      Singleton.instance = new Singleton();
    }
    return Singleton.instance;
  }
}
~~~



## 场景

### **Module**

通常的单例对象可能会是下边的样子，暴露几个方法供外界使用。

```js
var Singleton = {
  method1: function () {
    // ...
  },
  method2: function () {
    // ...
  }
};
```

但如果`Singleton` 有私有属性，可以写成下边的样子：

```js
var Singleton = {
  privateVar: '我是私有属性',
  method1: function () {
    // ...
  },
  method2: function () {
    // ...
  }
};
```

但此时外界就可以通过 `Singleton` 随意修改 `privateVar` 的值。

为了解决这个问题，我们可以借助闭包，通过 `IIFE (Immediately Invoked Function Expression)` 将一些属性和方法私有化。

```js
var myInstance = (function() {
  var privateVar = '';

  function privateMethod () {
    // ...
  }

  return { 
    method1: function () {
    },
    method2: function () {
    }
  };
})();
```

但随着 `ES6 Module` 的出现，我们很少像上边那样去定义一个模块了，而是通过单文件，一个文件就是一个模块，同时也可以看成一个**单例对象**。

```js
// 📁 singleton.js
const somePrivateState = []

function privateMethod () {
  // ...
}

export default {
  method1() {
    // ...
  },
  method2() {
    // ...
  }
}
```

然后使用的时候 `import` 即可。

```js
// 📁 main.js
import Singleton from './singleton.js'
// ...
```

即使有另一个文件也 `import` 了同一个文件。

```js
// 📁 main2.js
import Singleton from './singleton.js'
```

由于`Module`的特性：**模块代码仅在第一次导入时被解析**，因此这两个不同文件的 `import`的`Singleton` 是同一个对象。

那如果通过 `Webpack` 将 `ES6` 转成 `ES5` 以后呢，这种方式还会是单例对象吗？

答案当然是肯定的，可以看一下 `Webpack` 打包的产物，其实就是使用了 `IIFE` ，同时将第一次 `import` 的模块进行了缓存，第二次 `import` 的时候会使用之前的缓存。可以看下 `__webpack_require__` 的实现，和单例模式的逻辑是一样的。

```js
function __webpack_require__(moduleId) {
  var cachedModule = __webpack_module_cache__[moduleId];
  
  // 单例模式的应用
  if (cachedModule !== undefined) {
    return cachedModule.exports;
  }

  var module = (__webpack_module_cache__[moduleId] = {
    exports: {},
  });
  __webpack_modules__[moduleId](
    module,
    module.exports,
    __webpack_require__
  );
  return module.exports;
}
```

### Mitt 事件总线

~~~ts
export default function mitt<Events extends Record<EventType, unknown>>(
	all?: EventHandlerMap<Events>
): Emitter<Events> {
	type GenericEventHandler =
		| Handler<Events[keyof Events]>
		| WildcardHandler<Events>;
	all = all || new Map();

	return {
		all,

		on<Key extends keyof Events>(type: Key, handler: GenericEventHandler) {
			// ......
		},

		off<Key extends keyof Events>(type: Key, handler?: GenericEventHandler) {
			// ......
		},

		emit<Key extends keyof Events>(type: Key, evt?: Events[Key]) {
			// ......
	};
}
~~~

可以看到它直接将 `mitt` 这个函数导出了，如果每个页面都各自 `import` 它，然后通过 `mitt()` 来生成对象，那发布订阅就乱套了，因为它们不是同一个对象了。

为此，我们可以新建一个模块 / 文件，然后 `export` 一个实例化对象，其他页面去使用这个对象就实现单例模式了。

~~~js
import mitt from 'mitt'

const emitter = mitt()
~~~

### 实现一个 Storage

> 实现Storage，使得该对象为单例，基于 localStorage 进行封装。实现方法 setItem(key,value) 和 getItem(key)。

单例模式想要做到的是，**不管我们尝试去创建多少次，它都只给你返回第一次所创建的那唯一的一个实例**。

要做到这一点，就需要构造函数**具备判断自己是否已经创建过一个实例**的能力。我们现在把这段判断逻辑写成一个静态方法(其实也可以直接写入构造函数的函数体里）：

~~~js
class Storage {
  static getInstance() {
    if (!Storage.instance) {
      Storage.instance = new Storage();
    }
    return Storage.instance;
  }
  getItem(key) {
    return localStorage.getItem(key);
  }
  setItem(key, value) {
    return localStorage.setItem(key, value);
  }
}
~~~

ES5版本：

~~~js
function StorageBase() {}

StorageBase.prototype.getItem = function (key) {
  return localStorage.getItem(key);
};
StorageBase.prototype.setItem = function (key, value) {
  return localStorage.setItem(key, value);
};

const Storage = (function () {
  let instance = null;
  return function () {
    if (!instance) {
      instance = new StorageBase();
    }
    return instance;
  };
})();
~~~

### 实现一个全局Modal弹框



~~~html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>单例模式弹框</title>
</head>
<style>
    #modal {
        height: 200px;
        width: 200px;
        line-height: 200px;
        position: fixed;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        border: 1px solid black;
        text-align: center;
    }
</style>
<body>
    <button id="open">打开弹框</button>
    <button id="close">关闭弹框</button>
</body>
<script>
    // ES5实现单例模式
    const Modal = (function(){
        let modal = null;
        return function() {
            if(!modal) {
                modal = document.createElement('div');
                modal.innerHTML = '我是一个全局唯一的Modal';
                modal.id = 'modal';
                modal.style.display = 'none';
                document.body.appendChild(modal);
            }
            return modal;
        }
    })()

    document.getElementById('open').addEventListener('click', function(){
        const modal = new Modal();
        modal.style.display = 'block';
    })

    document.getElementById('close').addEventListener('click', function(){
        const modal = new Modal();
        if (modal) {
            modal.style.display = 'none';
        }
    })
</script>
</html>
~~~



















