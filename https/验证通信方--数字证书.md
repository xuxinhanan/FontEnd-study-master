## 数字证书和 CA

数字证书的作用，**是用来认证公钥持有者的身份**，以防止第三方进行冒充。因为谁都可以发布公钥，我们还缺少防止黑客伪造公钥的手段，也就是说，怎么来判断这个公钥就是目标服务器的公钥呢？

为此，需要借助“第三方”也就是 **CA**（证书认证机构）。**由它认证公钥持有者的身份（服务端的身份）。**

一个数字证书通常包含了：

- 公钥；
- 持有者信息；
- 证书认证机构（CA）的信息；
- CA 对这份文件的 **“数字签名”** 及使用的算法；
- 证书有效期；
- 还有一些其他额外信息；

----

之所以要签名，是因为签名的作用可以避免中间人在获取证书时对证书内容的篡改。

**:white_check_mark: 数字签名 = 摘要算法 + 私钥加密**

### 数字签名和验证流程



![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E8%AF%81%E4%B9%A6%E7%9A%84%E6%A0%A1%E9%AA%8C.png)

数字签名的签发过程：

+ 首先 CA 使用 **摘要（哈希）算法** 来计算数字证书的信息，并得出**信息摘要**；
+ 然后 CA 再使用它的 **私钥** 对信息摘要进行加密[^1]，**加密后的密文**就是 **“数字签名”**。



<img src="https://static001.geekbang.org/resource/image/84/d2/84a79826588ca35bf6ddcade027597d2.png?wh=1375*1252" alt="img" style="zoom: 33%;" />



客户端校验数字证书的完整性的过程：

- 首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；
- 通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；
- 最后比较 H1 和 H2，如果值相同，则为可信赖的证书。



---------



我们用证书来认证公钥持有者的身份（服务端的身份），那证书又是怎么来的？又该怎么认证证书呢？



-----



## 如何申请数字证书？

我们先来看看如何向 CA 申请证书。比如极客时间需要向某个 CA 去申请数字证书，通常的申请流程分以下几步：

+ 首先极客时间需要**准备一套私钥和公钥，私钥留着自己使用**；
+ 然后极客时间 **向 CA 机构提交公钥**、公司、站点等信息并等待认证，这个认证过程可能是收费的；
+ CA 通过线上、线下等多种渠道来验证极客时间所提供信息的真实性，如公司是否存在、企业是否合法、域名是否归属该企业等；
+ 如信息审核通过，CA 会向极客时间签发认证的数字证书，包含了极客时间的公钥、组织信息、CA 的信息、有效时间、证书序列号等，这些信息都是明文的，同时包含一个 CA 生成的**「数字签名」**。



--------



## 如何认证数字证书？

证书的验证过程中还存在⼀个证书信任链的问题，因为我们向 CA 申请的证书⼀般不是根证书签发的，⽽是由中间证书签发的，⽐如百度的证书，从下图你可以看到，证书的层级有三级：

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/baidu%E8%AF%81%E4%B9%A6.png)

但链条的最后，是 **“根证书”**。操作系统、浏览器本身会预装一些它们信任的根证书，如果其中会有 CA 机构的根证书，这样就可以拿到它对应的可信公钥了。

----------

对于这种三级层级关系的证书的验证过程如下：

- 客户端收到 baidu.com 的证书后，发现这个证书的签发者不是根证书，就无法根据本地已有的根证书中的公钥去验证 baidu.com 证书是否可信。于是，客户端根据 baidu.com 证书中的签发者，找到该证书的颁发机构，然后向 CA 请求该中间证书。
- 请求到证书后发现该中间证书是由 根证书 签发的，浏览器会检查此证书有否已预载，如果有，则可以利用根证书中的公钥去验证 中间证书。
- 中间证书被信任后，可以使用中间证书中的公钥去验证 baidu.com 证书的可信性，如果验证通过，就可以信任 baidu.com 证书。

------

整个证书信任链验证流程如下图所示：

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E8%AF%81%E4%B9%A6%E9%93%BE.png)



-------------





### 为什么私钥加签，公钥加密（握手协商中）？

:white_check_mark: **加签的目的：验证信息的发送方是否正确，信息是否被其他人篡改。**

之所以用发送方的私钥加签，是因为，即便信息被黑客拦截，黑客修改了信息，但是加签需要用发送方的私钥，黑客没有发送方的私钥，所以也无法生成正确的签名，接收方验签就不用通过。

反之如果用接收方的公钥加签，如果信息被黑客拦截，黑客修改了信息，因为接收方的公钥是公开的，黑客就可以重新生成新的签名，替换原有的签名，发送出去，接收方接收到信息，拿自己的公钥校验是通过的，所以接收方无法辨别信息是真正的发送方还是黑客发送过来的，这样的加签不能辨别信息是否被篡改过。

 

:white_check_mark: **加密的目的：保证信息的隐私，不被别人看到，只能让接收方看到正确的信息。**

之所以用接收方的公钥加密，是因为，如果信息被黑客拦截，需要用接收方的私钥来解密，黑客无法获取接收方的私钥，即便拦截了信息，黑客也无法看到明文。

反之，如果用发送方的私钥加密，如果信息被黑客拦截，因为发送方的公钥是公开的，黑客就可以用发送方的公钥解密密文获得明文，这样的加密所有的人都可以看到明文，不能保证信息的隐私。



-------









[^1]: 因为非对称加密效率太低，所以私钥只加密原文的摘要，这样运算量就小的多，而且得到的数字签名也很小，方便保管和传输。

