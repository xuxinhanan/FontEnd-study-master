### 数字签名

现实生活中，解决身份认证的手段是签名和印章，只要在纸上写下签名或者盖个章，就能够证明这份文件确实是由本人而不是其他人发出的。

而在TLS中，使用私钥再加上摘要算法，就能够实现“**数字签名**”。

数字签名的原理其实很简单，就是私钥加密、公钥解密[^1]。

<img src="https://static001.geekbang.org/resource/image/84/d2/84a79826588ca35bf6ddcade027597d2.png?wh=1375*1252" alt="img" style="zoom: 33%;" />

-------

### 为什么私钥加签，公钥加密？

:white_check_mark: **加签的目的：验证信息的发送方是否正确，信息是否被其他人篡改。**

之所以用发送方的私钥加签，是因为，即便信息被黑客拦截，黑客修改了信息，但是加签需要用发送方的私钥，黑客没有发送方的私钥，所以也无法生成正确的签名，接收方验签就不用通过。

反之如果用接收方的公钥加签，如果信息被黑客拦截，黑客修改了信息，因为接收方的公钥是公开的，黑客就可以重新生成新的签名，替换原有的签名，发送出去，接收方接收到信息，拿自己的公钥校验是通过的，所以接收方无法辨别信息是真正的发送方还是黑客发送过来的，这样的加签不能辨别信息是否被篡改过。

 

:white_check_mark: **加密的目的：保证信息的隐私，不被别人看到，只能让接收方看到正确的信息。**

之所以用接收方的公钥加密，是因为，如果信息被黑客拦截，需要用接收方的私钥来解密，黑客无法获取接收方的私钥，即便拦截了信息，黑客也无法看到明文。

反之，如果用发送方的私钥加密，如果信息被黑客拦截，因为发送方的公钥是公开的，黑客就可以用发送方的公钥解密密文获得明文，这样的加密所有的人都可以看到明文，不能保证信息的隐私。

----

总结数字签名的使用过程：

+ 首先 CA 使用 **摘要算法**来计算服务器提交的明文信息，并得出**信息摘要**；
+ 然后 CA 再使用它的**私钥**对信息摘要进行加密，加密后的密文就是 CA 颁给服务器的数字签名。

~~~
这样我们就可以通过公钥解密来验证是否是该 CA 颁发的
~~~

-------

### 数字证书和 CA

不过这里还有一个“**公钥的信任**”问题。因为谁都可以发布公钥，我们还缺少防止黑客伪造公钥的手段，也就是说，怎么来判断这个公钥就是你或者某宝的公钥呢？

为此，需要借助“第三方”也就是 **CA**（Certificate Authority，证书认证机构）。**由它来给各个公钥签名，用自身的信誉来保证公钥无法伪造，是可信的。**

CA 对公钥的签名认证也是有格式的，不是简单地把公钥绑定在持有者身份上就完事了，还要包含序列号、用途、颁发者、有效时间等等，把这些打成一个包再签名，完整地证明公钥关联的各种信息，形成**“数字证书”**（Certificate）。





### 那么如何申请数字证书？

我们先来看看如何向 CA 申请证书。比如极客时间需要向某个 CA 去申请数字证书，通常的申请流程分以下几步：

+ 首先极客时间需要**准备一套私钥和公钥，私钥留着自己使用**；
+ 然后极客时间 **向 CA 机构提交公钥**、公司、站点等信息并等待认证，这个认证过程可能是收费的；
+ CA 通过线上、线下等多种渠道来验证极客时间所提供信息的真实性，如公司是否存在、企业是否合法、域名是否归属该企业等；
+ 如信息审核通过，CA 会向极客时间签发认证的数字证书，包含了极客时间的公钥、组织信息、CA 的信息、有效时间、证书序列号等，这些信息都是明文的，同时包含一个 CA 生成的**「数字签名」**。



 























[^1]: 但又因为非对称加密效率太低，所以私钥只加密原文的摘要，这样运算量就小的多，而且得到的数字签名也很小，方便保管和传输。



[^2]: 签名和公钥一样完全公开，任何人都可以获取。但这个签名只有用私钥对应的公钥才能解开，拿到摘要后，再比对原文验证完整性，就可以像签署文件一样证明消息确实是你发的。

